---
description: Ultracite 规则 - AI 就绪的格式化器和代码检查器
globs: "**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

# 项目上下文
Ultracite 使用 Biome 的超快速格式化器和代码检查器，为 JavaScript/TypeScript 项目强制执行严格的类型安全、无障碍标准和一致的代码质量。

## 核心原则
- 零配置要求
- 亚秒级性能
- 最大化类型安全
- AI 友好的代码生成

## 编写代码前
1. 分析代码库中的现有模式
2. 考虑边界情况和错误场景
3. 严格遵循以下规则
4. 验证无障碍要求

## 规则

### 无障碍性 (a11y)
- 不要在任何 HTML 元素上使用 `accessKey` 属性。
- 不要在可聚焦元素上设置 `aria-hidden="true"`。
- 不要向不支持的元素添加 ARIA 角色、状态和属性。
- 不要使用分散注意力的元素，如 `<marquee>` 或 `<blink>`。
- 只在 `<th>` 元素上使用 `scope` 属性。
- 不要将非交互式 ARIA 角色分配给交互式 HTML 元素。
- 确保 label 元素有文本内容并与 input 关联。
- 不要将交互式 ARIA 角色分配给非交互式 HTML 元素。
- 不要将 `tabIndex` 分配给非交互式 HTML 元素。
- 不要对 `tabIndex` 属性使用正整数。
- 不要在 img 的 alt 属性中包含 "image"、"picture" 或 "photo"。
- 不要使用与隐式/默认角色相同的显式 role 属性。
- 确保带有点击处理程序的静态元素使用有效的 role 属性。
- 始终为 SVG 元素包含 `title` 元素。
- 为所有需要 alt 文本的元素提供对屏幕阅读器有意义的信息。
- 确保锚点有可被屏幕阅读器访问的内容。
- 为带有 `aria-activedescendant` 的非交互式 HTML 元素分配 `tabIndex`。
- 为具有 ARIA 角色的元素包含所有必需的 ARIA 属性。
- 确保 ARIA 属性对元素支持的角色有效。
- 始终为 button 元素包含 `type` 属性。
- 使具有交互式角色和处理程序的元素可聚焦。
- 为标题元素提供可被屏幕阅读器访问的内容（不要用 `aria-hidden` 隐藏）。
- 始终在 html 元素上包含 `lang` 属性。
- 始终为 iframe 元素包含 `title` 属性。
- `onClick` 应至少伴随以下之一：`onKeyUp`、`onKeyDown` 或 `onKeyPress`。
- `onMouseOver`/`onMouseOut` 应伴随 `onFocus`/`onBlur`。
- 为音频和视频元素包含字幕轨道。
- 在 JSX 中使用语义元素而不是 role 属性。
- 确保所有锚点都有效且可导航。
- 确保所有 ARIA 属性 (`aria-*`) 都有效。
- 为具有 ARIA 角色的元素使用有效的、非抽象的 ARIA 角色。
- 使用有效的 ARIA 状态和属性值。
- 为 input 元素的 `autocomplete` 属性使用有效值。
- 为 `lang` 属性使用正确的 ISO 语言/国家代码。

### 代码复杂度和质量
- 不要在正则表达式字面量中使用连续空格。
- 不要使用 `arguments` 对象。
- 不要使用原始类型别名或误导性类型。
- 不要使用逗号运算符。
- 不要在类型别名和接口中使用空类型参数。
- 不要编写超过给定认知复杂度分数的函数。
- 不要在测试文件中过度嵌套 describe() 块。
- 不要使用不必要的布尔转换。
- 不要在 flatMap 中使用不必要的回调。
- 使用 for...of 语句而不是 Array.forEach。
- 不要创建只有静态成员的类（类似静态命名空间）。
- 不要在静态上下文中使用 this 和 super。
- 不要使用不必要的 catch 子句。
- 不要使用不必要的构造函数。
- 不要使用不必要的 continue 语句。
- 不要导出不改变任何内容的空模块。
- 不要在正则表达式字面量中使用不必要的转义序列。
- 不要使用不必要的 fragments。
- 不要使用不必要的标签。
- 不要使用不必要的嵌套块语句。
- 不要将导入、导出和解构赋值重命名为相同的名称。
- 不要使用不必要的字符串或模板字面量连接。
- 当没有转义序列时，不要在模板字面量中使用 String.raw。
- 不要在 switch 语句中使用无用的 case 语句。
- 当存在更简单的替代方案时，不要使用三元运算符。
- 不要使用无用的 `this` 别名。
- 不要使用 any 或 unknown 作为类型约束。
- 不要将变量初始化为 undefined。
- 不要使用 void 运算符（它们不够熟悉）。
- 使用箭头函数而不是函数表达式。
- 使用 Date.now() 获取自 Unix 纪元以来的毫秒数。
- 尽可能使用 .flatMap() 而不是 map().flat()。
- 使用字面量属性访问而不是计算属性访问。
- 当二进制、八进制或十六进制字面量可行时，不要使用 parseInt() 或 Number.parseInt()。
- 使用简洁的可选链而不是链式逻辑表达式。
- 尽可能使用正则表达式字面量而不是 RegExp 构造函数。
- 不要使用非十进制或使用下划线分隔符的数字字面量对象成员名称。
- 从逻辑表达式中删除冗余项。
- 当不需要初始化和更新表达式时，使用 while 循环而不是 for 循环。
- 不要将 children 作为 props 传递。
- 不要重新分配 const 变量。
- 不要在条件中使用常量表达式。
- 当结果是常量时，不要使用 `Math.min` 和 `Math.max` 来限制值。
- 不要从构造函数返回值。
- 不要在正则表达式字面量中使用空字符类。
- 不要使用空解构模式。
- 不要将全局对象属性作为函数调用。
- 不要声明在其块外可访问的函数和 vars。
- 确保内置对象被正确实例化。
- 不要在类内部不正确地使用 super()。还要检查在扩展其他构造函数的类中调用 super()。
- 不要在声明之前使用变量和函数参数。
- 不要在字符串字面量中使用 8 和 9 转义序列。
- 不要使用会失去精度的字面量数字。

### React 和 JSX 最佳实践
- 不要使用 React.render 的返回值。
- 确保在 React hooks 中正确指定所有依赖项。
- 确保所有 React hooks 都从组件函数的顶层调用。
- 不要忘记在迭代器和集合字面量中使用 key props。
- 在 Solid 项目中不要在 JSX 组件内部解构 props。
- 不要在其他组件内部定义 React 组件。
- 不要在非交互式元素上使用事件处理程序。
- 不要分配给 React 组件的 props。
- 不要在同一元素上同时使用 `children` 和 `dangerouslySetInnerHTML` props。
- 不要使用危险的 JSX props。
- 不要在 keys 中使用数组索引。
- 不要将注释插入为文本节点。
- 不要多次分配 JSX 属性。
- 不要为没有子元素的组件添加额外的关闭标签。
- 使用 `<>...</>` 而不是 `<Fragment>...</Fragment>`。
- 注意 JSX 元素内部可能"错误"的分号。

### 正确性和安全性
- 不要将值分配给自身。
- 不要从 setter 返回值。
- 不要将修改字符串大小写的表达式与不合规的值进行比较。
- 不要在 switch 子句中使用词法声明。
- 不要使用未在文档中声明的变量。
- 不要编写不可达的代码。
- 如果类有超类，确保在访问 this 之前在类构造函数的每个代码路径上恰好调用一次 super()。
- 不要在 finally 块中使用控制流语句。
- 不要在不允许 undefined 值的地方使用可选链。
- 不要有未使用的函数参数。
- 不要有未使用的导入。
- 不要有未使用的标签。
- 不要有未使用的私有类成员。
- 不要有未使用的变量。
- 确保 void（自闭合）元素没有子元素。
- 不要从返回类型为 'void' 的函数返回值。
- 检查 NaN 时使用 isNaN()。
- 确保 "for" 循环的更新子句按正确方向移动计数器。
- 确保 typeof 表达式与有效值进行比较。
- 确保生成器函数包含 yield。
- 不要在循环内使用 await。
- 不要使用位运算符。
- 不要使用操作不改变值的表达式。
- 确保正确处理类 Promise 语句。
- 不要在全局作用域中使用 __dirname 和 __filename。
- 防止导入循环。
- 不要使用已配置的元素。
- 不要硬编码敏感数据，如 API 密钥和令牌。
- 不要让变量声明遮蔽外部作用域的变量。
- 不要使用 TypeScript 指令 @ts-ignore。
- 防止来自 Polyfill.io 的重复 polyfills。
- 不要在正则表达式中使用总是匹配空字符串的无用反向引用。
- 不要在字符串字面量中使用不必要的转义。
- 不要使用无用的 undefined。
- 确保同一属性的 getters 和 setters 在类和对象定义中相邻。
- 确保对象字面量声明一致（默认为显式定义）。
- 尽可能使用静态 Response 方法而不是 new Response() 构造函数。
- 确保 switch-case 语句是详尽的。
- 使用 Google Fonts 时确保使用 `preconnect` 属性。
- 查找项目索引时使用 `Array#{indexOf,lastIndexOf}()` 而不是 `Array#{findIndex,findLastIndex}()`。
- 确保可迭代回调返回一致的值。
- 对 JSON 模块导入使用 `with { type: "json" }`。
- 在数字字面量中使用数字分隔符。
- 构造新对象时使用对象展开而不是 `Object.assign()`。
- 使用 `parseInt()` 时始终使用 radix 参数。
- 确保 JSDoc 注释行以单个星号开头，除了第一行。
- 为 `Symbol()` 包含描述参数。
- 不要在累加器上使用展开 (`...`) 语法。
- 不要使用 `delete` 运算符。
- 不要动态访问命名空间导入。
- 不要使用命名空间导入。
- 在顶层声明正则表达式字面量。
- 不要在没有 `rel="noopener"` 的情况下使用 `target="_blank"`。

### TypeScript 最佳实践
- 不要使用 TypeScript 枚举。
- 不要导出已导入的变量。
- 不要向使用字面量表达式初始化的变量、参数和类属性添加类型注解。
- 不要使用 TypeScript 命名空间。
- 不要使用带有 `!` 后缀运算符的非空断言。
- 不要在类构造函数中使用参数属性。
- 不要使用用户定义的类型。
- 使用 `as const` 而不是字面量类型和类型注解。
- 一致地使用 `T[]` 或 `Array<T>`。
- 显式初始化每个枚举成员值。
- 对类型使用 `export type`。
- 对类型使用 `import type`。
- 确保所有枚举成员都是字面量值。
- 不要使用 TypeScript const 枚举。
- 不要声明空接口。
- 不要让变量通过重新赋值演变成 any 类型。
- 不要使用 any 类型。
- 不要在 TypeScript 文件中误用非空断言运算符 (!)。
- 不要在变量声明上使用隐式 any 类型。
- 不要不安全地合并接口和类。
- 不要使用不相邻的重载签名。
- 使用 namespace 关键字而不是 module 关键字来声明 TypeScript 命名空间。

### 风格和一致性
- 不要使用全局 `eval()`。
- 不要在异步测试和钩子中使用回调。
- 不要在有 `else` 子句的 `if` 语句中使用否定。
- 不要使用嵌套三元表达式。
- 不要重新分配函数参数。
- 此规则允许您指定不想在应用程序中使用的全局变量名称。
- 不要在通过 import 或 require 加载时使用指定的模块。
- 不要使用值为其名称大写版本的常量。
- 使用 `String.slice()` 而不是 `String.substr()` 和 `String.substring()`。
- 如果不需要插值或特殊字符处理，不要使用模板字面量。
- 当 `if` 块提前中断时，不要使用 `else` 块。
- 不要使用 yoda 表达式。
- 不要使用 Array 构造函数。
- 使用 `at()` 而不是整数索引访问。
- 遵循大括号约定。
- 在 `else` 子句中使用 `else if` 而不是嵌套的 `if` 语句。
- 使用单个 `if` 语句而不是嵌套的 `if` 子句。
- 对除 `String`、`Number` 和 `Boolean` 之外的所有内置对象使用 `new`。
- 在类属性和方法上使用一致的可访问性修饰符。
- 对只分配一次的变量使用 `const` 声明。
- 将默认函数参数和可选函数参数放在最后。
- 在 switch 语句中包含 `default` 子句。
- 使用 `**` 运算符而不是 `Math.pow`。
- 当需要索引从迭代数组中提取项目时，使用 `for-of` 循环。
- 使用 `node:assert/strict` 而不是 `node:assert`。
- 对 Node.js 内置模块使用 `node:` 协议。
- 使用 Number 属性而不是全局属性。
- 尽可能使用赋值运算符简写。
- 使用函数类型而不是带有调用签名的对象类型。
- 使用模板字面量而不是字符串连接。
- 抛出错误时使用 `new`。
- 不要抛出非 Error 值。
- 使用 `String.trimStart()` 和 `String.trimEnd()` 而不是 `String.trimLeft()` 和 `String.trimRight()`。
- 使用标准常量而不是近似字面量。
- 不要在表达式中分配值。
- 不要使用异步函数作为 Promise 执行器。
- 不要在 catch 子句中重新分配异常。
- 不要重新分配类成员。
- 不要与 -0 进行比较。
- 不要使用非循环的标记语句。
- 不要在泛型或返回类型之外使用 void 类型。
- 不要使用 console。
- 不要在正则表达式字面量中使用控制字符和匹配控制字符的转义序列。
- 不要使用 debugger。
- 不要直接分配给 document.cookie。
- 使用 `===` 和 `!==`。
- 不要使用重复的 case 标签。
- 不要使用重复的类成员。
- 不要在 if-else-if 链中使用重复的条件。
- 不要在对象内使用两个相同名称的键。
- 不要使用重复的函数参数名称。
- 不要在 describe 块中有重复的钩子。
- 不要使用空块语句和静态块。
- 不要让 switch 子句贯穿。
- 不要重新分配函数声明。
- 不要允许分配给原生对象和只读全局变量。
- 使用 Number.isFinite 而不是全局 isFinite。
- 使用 Number.isNaN 而不是全局 isNaN。
- 不要分配给导入的绑定。
- 不要使用不规则的空白字符。
- 不要使用与变量共享名称的标签。
- 不要在字符类语法中使用由多个代码点组成的字符。
- 确保正确使用 new 和构造函数。
- 当变量出现在两侧时，不要使用简写赋值。
- 不要在字符串字面量中使用八进制转义序列。
- 不要直接使用 Object.prototype 内置对象。
- 不要在同一作用域中重新声明变量、函数、类和类型。
- 不要有冗余的 "use strict"。
- 不要比较两侧完全相同的内容。
- 不要让标识符遮蔽受限制的名称。
- 不要使用稀疏数组（有孔的数组）。
- 不要在常规字符串中使用模板字面量占位符语法。
- 不要使用 then 属性。
- 不要使用不安全的否定。
- 不要使用 var。
- 不要在非严格上下文中使用 with 语句。
- 确保异步函数实际使用 await。
- 确保 switch 语句中的 default 子句在最后。
- 创建内置错误时确保传递消息值。
- 确保 get 方法始终返回值。
- 对 Google Fonts 使用推荐的显示策略。
- 确保 for-in 循环包含 if 语句。
- 使用 Array.isArray() 而不是 instanceof Array。
- 确保在 Number#toFixed() 中使用 digits 参数。
- 确保在脚本文件中使用 "use strict" 指令。

### Next.js 特定规则
- 不要在 Next.js 项目中使用 `<img>` 元素。
- 不要在 Next.js 项目中使用 `<head>` 元素。
- 不要在 Next.js 项目的 pages/_document.jsx 之外导入 next/document。
- 不要在 Next.js 项目的 pages/_document.js 中使用 next/head 模块。

### 测试最佳实践
- 不要在测试文件中使用 export 或 module.exports。
- 不要使用聚焦测试。
- 确保断言函数（如 expect）放置在 it() 函数调用内部。
- 不要使用禁用的测试。

## 常见任务
- `npx ultracite init` - 在项目中初始化 Ultracite
- `npx ultracite fix` - 自动格式化和修复代码
- `npx ultracite check` - 检查问题但不修复

## 示例：错误处理
```typescript
// ✅ 好：全面的错误处理
try {
  const result = await fetchData();
  return { success: true, data: result };
} catch (error) {
  console.error('API call failed:', error);
  return { success: false, error: error.message };
}

// ❌ 坏：吞没错误
try {
  return await fetchData();
} catch (e) {
  console.log(e);
}
```